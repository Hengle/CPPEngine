[Vertex shader]
ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;

struct SkyVS_INPUT
{
    float3 position	: POSITION;
};
struct SkyVS_OUTPUT
{
    float4 position : POSITION;
    float4 texcoord  : TEXCOORD0;

    //float2 intensitySqrdintensity : TEXCOORD1;
    float positionyparamsy : TEXCOORD1;
};
float4	params;
float3	offset;
//varying float intensitySqrd, intensity;
SkyVS_OUTPUT main(SkyVS_INPUT IN)
{
	SkyVS_OUTPUT OUT;
	float2 newUV  = float2((IN.position.x - offset.x)/params.x,
			   (IN.position.z - offset.z)/params.z);

	OUT.texcoord.x	= newUV.x + params.w*0.66;
	OUT.texcoord.y	= newUV.y + params.w*0.33;
	OUT.texcoord.xy *= 2.0;

	OUT.texcoord.z = newUV.x + params.w*1.33;
	OUT.texcoord.w = newUV.y + params.w*1.66;
	OUT.texcoord.zw *= 3.0;
#if 0
	//Get the vertex height and scale it to 0 - 1 range
	OUT.intensitySqrdintensity.y	 = IN.position.y/params.y;
	OUT.intensitySqrdintensity.y	 = exp(clamp(OUT.intensitySqrdintensity.y, 0.0, 1.0))/2.8;
	OUT.intensitySqrdintensity.x	 = OUT.intensitySqrdintensity.y*OUT.intensitySqrdintensity.y;
#else
	OUT.positionyparamsy=IN.position.y/params.y;
#endif
	OUT.position = mul( float4(IN.position, 1),worldViewProj );
	return OUT;
}
[Fragment shader]
struct SkyPS_OUTPUT
{
	float4 color : COLOR;
};

struct SkyVS_OUTPUT
{
    float4 position : POSITION;
    float4 texcoord  : TEXCOORD0;

    //float2 intensitySqrdintensity : TEXCOORD1;
    float positionyparamsy : TEXCOORD1;
};

float4	skyInfo;
texture2D noiseTexture; // This texture will be loaded by the application
sampler2D shape = sampler_state
{
    Texture   = (noiseTexture);
/*
	V(g_pd3dDevice->SetTexture(currUnit,NULL));
	V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP));
	V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP));
	//V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_ADDRESSW, D3DTADDRESS_WRAP));
	V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_MAGFILTER, D3DTEXF_POINT));
	V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_MINFILTER, D3DTEXF_POINT));
	//V(g_pd3dDevice->SetSamplerState(currUnit, D3DSAMP_MIPFILTER, D3DTEXF_NONE));
*/
   ADDRESSU = WRAP;
   ADDRESSV = WRAP;
   ADDRESSW = WRAP;    
    MipFilter = NONE;
    MinFilter = POINT;
    MagFilter = POINT;
};

SkyPS_OUTPUT main(SkyVS_OUTPUT IN)
{
	SkyPS_OUTPUT OUT;	
#if 1
	float4 noise1	= tex2D(shape, IN.texcoord.xy),
	     noise2	= tex2D(shape, IN.texcoord.zw);

#if 0
	float4 cloudFrag	= (noise1 + noise2) *  IN.intensitySqrdintensity.x,
	     cloudColor = float4((1.0 - IN.intensitySqrdintensity.y)*skyInfo.x,
			       (1.0 - IN.intensitySqrdintensity.y)*skyInfo.y,
			       IN.intensitySqrdintensity.y*skyInfo.z, 0.0);
#else
	//Get the vertex height and scale it to 0 - 1 range
	float intensitySqrdintensityy	 = IN.positionyparamsy;
	intensitySqrdintensityy  = exp(clamp(intensitySqrdintensityy, 0.0, 1.0))/2.8;
	float intensitySqrdintensityx	 = intensitySqrdintensityy*intensitySqrdintensityy;
	float4 cloudFrag	= (noise1 + noise2) *  intensitySqrdintensityx,
	     cloudColor = float4((1.0 - intensitySqrdintensityy)*skyInfo.x,
			       (1.0 - intensitySqrdintensityy)*skyInfo.y,
			       intensitySqrdintensityy*skyInfo.z, 0.0);
#endif
	OUT.color	= cloudColor * (1.0 - cloudFrag.x) + cloudFrag;
	// Gamma from 9.99 to 0.1
	float gamma=1.5;
	OUT.color.r=pow(abs(OUT.color.r), 1.0 / gamma);
	OUT.color.g=pow(abs(OUT.color.g), 1.0 / gamma);
	OUT.color.b=pow(abs(OUT.color.b), 1.0 / gamma);

#else
	OUT.color=float4(1,1,1,1);
#endif
	return OUT;
}
