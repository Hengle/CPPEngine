[Vertex shader]
//ROW_MAJOR float4x4 proj;
//ROW_MAJOR float4x4 worldView;
ROW_MAJOR float4x4 worldViewProj MVPSEMANTIC;
struct VS_INPUT
{
	float3 position  : POSITION;
	float2 texcoord0 : TEXCOORD0;
};

struct VS_OUTPUT
{
	float4 hposition : POSITION;
	float2 texcoord0 : TEXCOORD0;
};
		  /*
sampler2D Sampler;
		*/
VS_OUTPUT mainVS( VS_INPUT IN )
{
	VS_OUTPUT OUT;

	float4 v;
#if 1
	v=float4( IN.position.x,
			       IN.position.y,
					   IN.position.z,
					   1.0f );
#else
	//v = tex2Dlod(Sampler, float4(IN.texcoord0.xy + 0.5, 0.0, 0.0));
	v = tex2Dbias(Sampler, float4(IN.texcoord0.xy + 0.5, 0.0, 0.0));//CG???
#endif

	//worldViewProj=worldView*proj;
   //OUT.hposition = mul( v,worldViewProj );//DX11
    OUT.hposition = mul( worldViewProj ,v);
        
    OUT.texcoord0 = IN.texcoord0;

    return OUT;
}

[Fragment shader]
struct VS_OUTPUT
{
	float4 hposition : POSITION;
	float2 texcoord0 : TEXCOORD0;
};

struct PS_OUTPUT
{
	float4 color : COLOR;
};

sampler2D Sampler;
PS_OUTPUT mainPS( VS_OUTPUT IN )
{
	PS_OUTPUT OUT;

	OUT.color = tex2D( Sampler, IN.texcoord0 );
			
	// Gamma from 9.99 to 0.1
	float gamma=1.5;
	OUT.color.r=pow(abs(OUT.color.r), 1.0 / gamma);
	OUT.color.g=pow(abs(OUT.color.g), 1.0 / gamma);
	OUT.color.b=pow(abs(OUT.color.b), 1.0 / gamma);
	
	return OUT;
}
